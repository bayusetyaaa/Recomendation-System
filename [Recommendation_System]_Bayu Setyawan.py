# -*- coding: utf-8 -*-
"""Copy of Recommendation System

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/13EawXgRBOYgzorrvPw83OaAuah-yOzEn

# Project Overview

**Latar Belakang :**

Dalam era digital saat ini, volume konten hiburan yang tersedia secara online tumbuh secara eksponensial. Platform seperti Netflix, Disney+, dan lainnya menyediakan ribuan pilihan film dan serial yang terus bertambah setiap hari. Namun, banyaknya pilihan justru menjadi tantangan tersendiri: pengguna sering merasa kewalahan dan kesulitan dalam menemukan tayangan yang sesuai dengan minat mereka. Hal ini berdampak pada turunnya pengalaman pengguna dan menurunnya loyalitas terhadap platform.

**Mengapa Project ini penting :**

1. **Pengalaman Pengguna yang Lebih Personal**
   Sistem rekomendasi yang baik membantu menyajikan konten yang sesuai dengan preferensi pengguna, tanpa harus mencarinya secara manual.

2. **Efisiensi Navigasi Konten**
   Dengan menyaring konten berdasarkan minat dan riwayat interaksi, pengguna dapat menghemat waktu dalam menemukan tayangan yang diinginkan.

# Business Undrestanding

**Problem Statement :**

1. **Bagaimana mengidentifikasi kesamaan antara film untuk menyarankan konten yang sesuai bagi pengguna?**

   * Menggunakan fitur-fitur seperti genre, popularitas, dan tahun rilis untuk menemukan keterkaitan antar film.

2. **Apa pendekatan terbaik untuk menyusun rekomendasi yang tidak monoton atau terlalu seragam?**

   * Dibutuhkan strategi untuk memperkenalkan keberagaman konten, agar pengguna tidak hanya mendapat saran dari genre atau tipe film yang sama.

3. **Bagaimana menyusun sistem yang tetap relevan meskipun pengguna tidak memberikan banyak umpan balik (seperti rating)?**

   * Fokus pada pendekatan berbasis konten (content-based) yang tidak sepenuhnya bergantung pada interaksi pengguna.

**Goals :**

1. **Membuat prototipe sistem rekomendasi yang mampu mengenali karakteristik film secara otomatis** dan menyarankan tayangan berdasarkan kedekatan atribut.
2. **Menerapkan teknik pengukuran kesamaan (similarity)** untuk menilai sejauh mana satu film mirip dengan film lainnya menggunakan data struktural.
3. **Mengintegrasikan elemen keberagaman dalam sistem rekomendasi**, agar pengguna tidak merasa jenuh dengan saran yang terlalu mirip secara berturut-turut.

# Import Library
"""

# Import library
import pandas as pd
import numpy as np
from zipfile import ZipFile
import tensorflow as tf
from tensorflow import keras
from tensorflow.keras import layers, Model
from pathlib import Path
import matplotlib.pyplot as plt
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity
import kagglehub
import os

"""# Data Understanding

Data yang digunakan adalah **MovieLens Latest Small Dataset** yang tersedia di Kaggle:
ðŸ”— [https://www.kaggle.com/datasets/grouplens/movielens-latest-small](https://www.kaggle.com/datasets/grouplens/movielens-latest-small)

Dataset ini berisi informasi mengenai:

* **movies.csv** â€“ data film termasuk movieId, title, dan genres
* **ratings.csv** â€“ data rating pengguna terhadap film (userId, movieId, rating, timestamp)
* **tags.csv** â€“ data tag yang diberikan pengguna terhadap film
* **links.csv** â€“ penghubung antara movieId dan ID film dari sumber eksternal seperti IMDB dan TMDb
"""

#!/bin/bash
!curl -L -o movielens-latest-small.zip\
  https://www.kaggle.com/api/v1/datasets/download/grouplens/movielens-latest-small

!unzip movielens-latest-small.zip

movies = pd.read_csv('movies.csv')
links = pd.read_csv('links.csv')
tags = pd.read_csv('tags.csv')
ratings = pd.read_csv('ratings.csv')

print('Jumlah data film: ', len(movies.movieId.unique()))
print('Jumlah data link film: ', len(links.movieId.unique()))
print('Jumlah data tag pada film yang diberikan pengguna: ', len(tags.tag.unique()))
print('Jumlah data penilaian yang diberikan pengguna: ', len(ratings))

"""# Univariate Exploratory Data Analysis

**Variabel-variabel pada MovieLens Latest Dataset adalah sebagai berikut:**

* **movies** : merupakan metadata dari setiap film, yang mencakup informasi seperti judul dan genre.
* **links** : merupakan ID referensi eksternal film yang terhubung ke situs IMDb dan TMDb.
* **tags** : merupakan kata kunci atau deskripsi tambahan yang diberikan oleh pengguna terhadap film tertentu.
* **ratings** : berisi data penilaian (rating) yang diberikan pengguna terhadap film, termasuk userId, movieId, rating, dan timestamp.

Data yang tersedia memang terlihat cukup sederhana, namun cukup representatif untuk membangun sistem rekomendasi. Dalam tahap awal ini, kita akan mengambil sampel berdasarkan kombinasi movieId dan userId dari file **ratings.csv**.

## Movies

Menampilkan informasi umum tentang struktur DataFrame, termasuk jumlah entri, jumlah kolom, nama dan tipe data setiap kolom, serta jumlah non-null pada masing-masing kolom.
"""

movies.info()

"""Berdasarkan output di atas, dataset movies memiliki **9742 entri (baris)** dan **3 kolom**, yaitu:

* movieId : ID unik untuk setiap film dengan tipe data int64
* title : Judul film dengan tipe data object (string)
* genres : Genre film dengan tipe data object (string), berisi satu atau lebih genre yang dipisahkan dengan simbol |

Menampilkan 5 baris pertama dari DataFrame untuk melihat contoh isi data pada setiap kolom.
"""

movies.head()

"""Mengekstrak dan menampilkan daftar genre unik yang terdapat dalam dataset movies"""

# filter berdasarkan genre
unique_genres = set()

for genre_list in movies['genres']:
    genres_split = genre_list.split('|')
    unique_genres.update(genres_split)

print(f"Terdapat {len(unique_genres)} jenis genre:")
print(sorted(unique_genres))

"""Berdasarkan output di atas, terdapat 20 jenis genre unik dalam dataset movies. Genre (no genres listed) menunjukkan bahwa terdapat film yang belum memiliki informasi genre.

Melakukan filter terhadap data untuk menemukan film yang tidak memiliki genre
"""

# Filter film yang tidak memiliki genre (no genres listed)
no_genre_movies = movies[movies['genres'] == '(no genres listed)']

print(f"Jumlah film yang tidak memiliki genre (no genres listed): {len(no_genre_movies)}")

"""Berdasarkan hasil filter, terdapat 34 film dalam dataset yang tidak memiliki informasi genre ('(no genres listed)').

## Links

Menampilkan informasi struktur DataFrame links, termasuk jumlah entri, jumlah kolom, tipe data, dan jumlah non-null pada masing-masing kolom.
"""

links.info()

"""Berdasarkan output di atas, dataset links memiliki **9742 entri** dan **3 kolom**, yaitu:

* movieId : ID film yang sama dengan movieId pada dataset movies (tipe int64)
* imdbId : ID film pada basis data **IMDb** (tipe int64)
* tmdbId : ID film pada basis data **TMDb (The Movie Database)** (tipe float64)

Menampilkan 5 baris pertama dari DataFrame untuk melihat contoh isi data pada setiap kolom.
"""

links.head()

"""## Tags

Menampilkan informasi struktur DataFrame tags, termasuk jumlah entri, nama dan tipe kolom, jumlah nilai non-null di setiap kolom.
"""

tags.info()

"""Berdasarkan output di atas, dataset tags memiliki **3683 entri** dan **4 kolom**, yaitu:

* userId : ID pengguna yang memberikan tag (tipe int64)
* movieId : ID film yang diberi tag (tipe int64)
* tag : Tag atau label yang diberikan pengguna untuk film tersebut (tipe object)
* timestamp : Waktu saat tag diberikan dalam bentuk timestamp UNIX (tipe int64)

Menampilkan 5 baris pertama dari DataFrame untuk melihat contoh isi data pada setiap kolom.
"""

tags.head()

"""## Ratings

Menampilkan 5 baris pertama dari DataFrame untuk melihat contoh isi data pada setiap kolom.
"""

ratings.head()

"""Melihat statistik deskriptif dari dataset rating."""

ratings.describe()

"""Menampilkan jumlah data (count), nilai rata-rata (mean), standar deviasi (std), nilai minimum, kuartil (25%, 50%, 75%), dan nilai maksimum untuk setiap kolom numerik.

Menghitung jumlah unik pengguna, jumlah unik film, dan total jumlah data rating yang terdapat dalam dataset ratings.
"""

print('Jumlah userID: ', len(ratings.userId.unique()))
print('Jumlah placeID: ', len(ratings.movieId.unique()))
print('Jumlah data rating: ', len(ratings))

"""Berdasarkan output di atas:

* Jumlah pengguna unik (`userId`) yang memberikan rating adalah **610**
* Jumlah film unik (`movieId`) yang telah diberi rating adalah **9724**
* Total jumlah rating yang tercatat dalam dataset adalah **100,836**

# Data Preprocessing

## Menggabungkan Data dengan Fitur Nama film

mendefinisikan dataframe rating ke dalam variabel all_movie_rate
"""

all_movie_rate = ratings
all_movie_rate

"""Menggabungkan DataFrame all_movie_rate dengan DataFrame movies berdasarkan kolom movieId menggunakan metode left join, sehingga setiap baris rating akan dilengkapi dengan informasi judul film (title)."""

# Menggabungkan all movie_rate dengan dataframe movies berdasarkan movieId
all_movie_name = pd.merge(all_movie_rate, movies[['movieId', 'title']], on='movieId', how='left')

# Print dataframe all_movie_name
all_movie_name

"""##  Menggabungkan Data Rating dengan Fitur Genre Film

Menggabungkan Data Rating dengan Fitur Genre Film
"""

movies_ratings = pd.merge(ratings, movies, on='movieId', how='left')
movies_ratings

"""Melakukan pengelompokan data berdasarkan movieId dan title, kemudian menghitung jumlah total rating untuk setiap film. Hasilnya diurutkan dari yang memiliki total rating tertinggi ke yang terendah."""

movies_ratings[['movieId', 'title', 'rating']].groupby(['movieId', 'title']).sum().reset_index().sort_values(by='rating', ascending=False)

"""# Data Preparation

## Mengatasi Missing Value

Mengecek missing value pada dataframe movies_ratings
"""

movies_ratings.isnull().sum()

"""berdasarkan hasil pengecekan dapat diinfokan bahwa tidak terdapat missing value

Mengecek missing value pada dataframe all_movie_name
"""

all_movie_name.isnull().sum()

"""berdasarkan hasil pengecekan dapat diinfokan bahwa tidak terdapat missing value

## Menggabungkan Data Rating dengan Fitur Genre Film

Membuat variabel preparation yang berisi dataframe movies_ratings tanpa nilai movieId yang duplikat
"""

preparation = movies_ratings
preparation.sort_values('movieId')

"""Membuang data duplikat pada variabel preparation"""

preparation = preparation.drop_duplicates('movieId')
preparation

"""Mengonversi kolom movieId, title, dan genres dari DataFrame preparation menjadi list untuk memudahkan pemrosesan data lebih lanjut.

"""

# Mengonversi data series â€˜movieIdâ€™ menjadi dalam bentuk list
movie_id = preparation['movieId'].tolist()

# Mengonversi data series â€˜titleâ€™ menjadi dalam bentuk list
movie_title = preparation['title'].tolist()

# Mengonversi data series â€˜genresâ€™ menjadi dalam bentuk list
movie_genres = preparation['genres'].tolist()

print(len(movie_id))
print(len(movie_title))
print(len(movie_genres))

"""Membuat dictionary untuk data movie_id, movie_title, dan movie_genres"""

movie_new = pd.DataFrame({
    'id': movie_id,
    'movie_title': movie_title,
    'movie_genres': movie_genres
})
movie_new

"""# Model Development Content Based Filtering

Menampilkan 5 baris data acak dari DataFrame movie_new untuk melihat sampel isi dataset secara acak.
"""

data = movie_new
data.sample(5)

"""## TF-IDF Vectorizer

Menginisialisasi model TfidfVectorizer
"""

# Inisialisasi TfidfVectorizer
vectorizer = TfidfVectorizer()

# Melakukan perhitungan idf pada data genres
vectorizer.fit(data['movie_genres'])

# Mapping array dari fitur index integer ke fitur nama
vectorizer.get_feature_names_out()

"""Melakukan fit lalu ditransformasikan ke bentuk matrix"""

tfidf_matrix = vectorizer.fit_transform(data['movie_genres'])
tfidf_matrix.shape

"""Mengubah vektor tf-idf dalam bentuk matriks dengan fungsi todense()"""

tfidf_matrix.todense()

"""Membuat dataframe untuk melihat tf-idf matrix"""

# Membuat dataframe untuk melihat tf-idf matrix
# Kolom diisi dengan genre film
# Baris diisi dengan judul film

pd.DataFrame(
    tfidf_matrix.todense(),
    columns=vectorizer.get_feature_names_out(),
    index=data.movie_title
).sample(21, axis=1).sample(10, axis=0)

"""## Cosine Similarity

Menghitung cosine similarity pada matrix tf-idf
"""

cosine_sim = cosine_similarity(tfidf_matrix)
cosine_sim

"""Membuat dataframe dari variabel cosine_sim dengan baris dan kolom berupa judul film"""

cosine_sim_df = pd.DataFrame(cosine_sim, index=data['movie_title'], columns=data['movie_title'])
print('Shape:', cosine_sim_df.shape)

cosine_sim_df.sample(5, axis=1).sample(10, axis=0)

"""## Mendapatkan Rekomendasi

Mendefinisikan fungsi untuk merekomendasikan k film yang paling mirip berdasarkan skor kemiripan antar judul film menggunakan data cosine_sim_df.
"""

def movie_recommendations(judul_film, similarity_data=cosine_sim_df, items=data[['movie_title', 'movie_genres']], k=5):
    """
    Rekomendasi film berdasarkan kemiripan dataframe

    Parameter:
    ---
    judul_film : tipe data string (str)
                Judul film (index kemiripan dataframe)
    similarity_data : tipe data pd.DataFrame (object)
                      Kesamaan dataframe, simetrik, dengan judul film sebagai
                      indeks dan kolom
    items : tipe data pd.DataFrame (object)
            Mengandung kedua nama dan fitur lainnya yang digunakan untuk mendefinisikan kemiripan
    k : tipe data integer (int)
        Banyaknya jumlah rekomendasi yang diberikan
    ---


    Pada index ini, kita mengambil k dengan nilai similarity terbesar
    pada index matrix yang diberikan (i).
    """

    # Mengambil data dengan menggunakan argpartition untuk melakukan partisi secara tidak langsung sepanjang sumbu yang diberikan
    # Dataframe diubah menjadi numpy
    # Range(start, stop, step)
    index = similarity_data.loc[:,judul_film].to_numpy().argpartition(
        range(-1, -k, -1))

    # Mengambil data dengan similarity terbesar dari index yang ada
    closest = similarity_data.columns[index[-1:-(k+2):-1]]

    # Drop judul_film agar judul film yang dicari tidak muncul dalam daftar rekomendasi
    closest = closest.drop(judul_film, errors='ignore')

    return pd.DataFrame(closest).merge(items).head(k)

"""Mencari dan menampilkan baris data yang memiliki judul film "Good Time (2017)" dari DataFrame data."""

data[data.movie_title.eq('Good Time (2017)')]

"""berdasarkan output tersebut film "Good Time (2017) berada pada id "174727" dengan genre "Crime|Drama"

Menampilkan 5 rekomendasi film yang paling mirip dengan "Good Time (2017)" berdasarkan kemiripan genre menggunakan pendekatan TF-IDF dan cosine similarity.
"""

movie_recommendations('Good Time (2017)')

"""Berdasarkan hasil rekomendasi menggunakan metode **TF-IDF dan cosine similarity** terhadap genre film, sistem berhasil menyarankan 5 film yang memiliki genre serupa dengan **"Good Time (2017)"**, yaitu **Crime** dan **Drama**.

# Model Development dengan Collaborative Filtering

Membaca dataset
"""

df = movies_ratings.drop(['genres', 'title'], axis=1)
df

"""## Data Preparation

Mengonversi userId unik ke dalam list, melakukan encoding dari userId ke indeks numerik, serta menyediakan mapping balik dari indeks ke userId.
"""

# Mengubah userId menjadi list tanpa nilai yang sama
user_ids = df['userId'].unique().tolist()
print('list userId: ', user_ids)

# Melakukan encoding userId
user_to_user_encoded = {x: i for i, x in enumerate(user_ids)}
print('encoded userId : ', user_to_user_encoded)

# Melakukan proses encoding angka ke ke userId
user_encoded_to_user = {i: x for i, x in enumerate(user_ids)}
print('encoded angka ke userId: ', user_encoded_to_user)

"""Terdapat 610 pengguna unik, dan setiap userId telah berhasil diubah ke indeks numerik (0â€“609) menggunakan dua mappingâ€”untuk konversi dua arah antara userId asli dan indeksâ€”yang siap digunakan dalam model berbasis matriks atau embedding.

Mengonversi movieId unik ke dalam list, lalu membuat dua dictionary untuk encoding movieId ke indeks numerik dan sebaliknya.
"""

# Mengubah movieId menjadi list tanpa nilai yang sama
movie_ids = df['movieId'].unique().tolist()

# Melakukan proses encoding movieId
movie_to_movie_encoded = {x: i for i, x in enumerate(movie_ids)}

# Melakukan proses encoding angka ke movieId
movie_encoded_to_movie = {i: x for i, x in enumerate(movie_ids)}

"""Melakukan mapping userId dan movieId ke bentuk encoded numerik di dataframe utama (df)."""

# Mapping userId ke dataframe user
df['user'] = df['userId'].map(user_to_user_encoded)

# Mapping movieId ke dataframe movie
df['movie'] = df['movieId'].map(movie_to_movie_encoded)

"""Mendapatkan statistik dasar seperti jumlah user, jumlah film, serta nilai minimum dan maksimum dari rating."""

# Mendapatkan jumlah user
num_users = len(user_to_user_encoded)
print(num_users)

# Mendapatkan jumlah film
num_movie = len(movie_to_movie_encoded)
print(num_movie)

# Mengubah rating menjadi nilai float
df['rating'] = df['rating'].values.astype(np.float32)

# Nilai minimum rating
min_rating = min(df['rating'])

# Nilai maksimal rating
max_rating = max(df['rating'])

print('Number of User: {}, Number of Movie: {}, Min Rating: {}, Max Rating: {}'.format(
    num_users, num_movie, min_rating, max_rating
))

"""## Membagi Data untuk Training dan Validasi

Mengacak urutan baris pada dataframe df secara acak namun reproducible dengan random_state.
"""

df = df.sample(frac=1, random_state=42)
df

"""Mempersiapkan data input (x) dan target (y) untuk model, lalu membaginya menjadi data Training dan validasi."""

# Membuat variabel x untuk mencocokkan data user dan movie menjadi satu value
x = df[['user', 'movie']].values

# Membuat variabel y untuk membuat rating dari hasil
y = df['rating'].apply(lambda x: (x - min_rating) / (max_rating - min_rating)).values

# Membagi menjadi 80% data train dan 20% data validasi
train_indices = int(0.8 * df.shape[0])
x_train, x_val, y_train, y_val = (
    x[:train_indices],
    x[train_indices:],
    y[:train_indices],
    y[train_indices:]
)

print(x, y)

"""## Proses Training

melakukan pemodelan RecommenderNet menggunakan pendekatan matrix factorization berbasis embedding untuk memprediksi skor kecocokan antara pengguna dan film menggunakan arsitektur Keras.
"""

class RecommenderNet(tf.keras.Model):

  # Insialisasi fungsi
  def __init__(self, num_users, num_movie, embedding_size, **kwargs):
    super(RecommenderNet, self).__init__(**kwargs)
    self.num_users = num_users
    self.num_movie = num_movie
    self.embedding_size = embedding_size
    self.user_embedding = layers.Embedding( # layer embedding user
        num_users,
        embedding_size,
        embeddings_initializer = 'he_normal',
        embeddings_regularizer = keras.regularizers.l2(1e-6)
    )
    self.user_bias = layers.Embedding(num_users, 1) # layer embedding user bias
    self.movie_embedding = layers.Embedding( # layer embeddings movie
        num_movie,
        embedding_size,
        embeddings_initializer = 'he_normal',
        embeddings_regularizer = keras.regularizers.l2(1e-6)
    )
    self.movie_bias = layers.Embedding(num_movie, 1) # layer embedding movie bias

  def call(self, inputs):
    user_vector = self.user_embedding(inputs[:,0]) # memanggil layer embedding 1
    user_bias = self.user_bias(inputs[:, 0]) # memanggil layer embedding 2
    movie_vector = self.movie_embedding(inputs[:, 1]) # memanggil layer embedding 3
    movie_bias = self.movie_bias(inputs[:, 1]) # memanggil layer embedding 4

    dot_user_movie = tf.tensordot(user_vector, movie_vector, 2)

    x = dot_user_movie + user_bias + movie_bias

    return tf.nn.sigmoid(x) # activation sigmoid

""" inisialisasi model"""

model = RecommenderNet(num_users, num_movie, 50)

# model compile
model.compile(
    loss = tf.keras.losses.BinaryCrossentropy(),
    optimizer = keras.optimizers.Adam(learning_rate=0.001),
    metrics=[tf.keras.metrics.RootMeanSquaredError()]
)

"""Memulai training model"""

history = model.fit(
    x = x_train,
    y = y_train,
    batch_size = 32,
    epochs = 50,
    validation_data = (x_val, y_val)
)

"""## Visualisasi Metrik

visualisasi grafik RMSE Train dan Validation
"""

plt.plot(history.history['root_mean_squared_error'])
plt.plot(history.history['val_root_mean_squared_error'])
plt.title('Grafik RMSE Train dan Validation')
plt.ylabel('root_mean_squared_error')
plt.xlabel('epoch')
plt.legend(['train', 'validation'], loc='upper left')
plt.show()

"""Grafik menunjukkan bahwa nilai RMSE pada data training terus menurun seiring bertambahnya epoch, sementara nilai RMSE pada data validation cenderung stabil setelah beberapa epoch. Ini menandakan model berhasil mempelajari pola dari data.

## Mendapatkan Rekomendasi Film

Membuat array kombinasi user dan film yang belum ditonton untuk keperluan prediksi rekomendasi.
"""

movie_df = movie_new
df = movies_ratings.drop(['genres', 'title'], axis=1)

# Mengambil sample user
user_id = df.userId.sample(1).iloc[0]
movie_watched_by_user = df[df.userId == user_id]

# Operator bitwise (~), bisa diketahui di sini https://docs.python.org/3/reference/expressions.html
movie_not_watched = movie_df[~movie_df['id'].isin(movie_watched_by_user.movieId.values)]['id']
movie_not_watched = list(
    set(movie_not_watched)
    .intersection(set(movie_to_movie_encoded.keys()))
)

movie_not_watched = [[movie_to_movie_encoded.get(x)] for x in movie_not_watched]
user_encoder = user_to_user_encoded.get(user_id)
user_movie_array = np.hstack(
    ([[user_encoder]] * len(movie_not_watched), movie_not_watched)
)

"""Menampilkan film terbaik yang pernah ditonton user dan memberikan 10 rekomendasi film berdasarkan prediksi model."""

ratings = model.predict(user_movie_array).flatten()

top_ratings_indices = ratings.argsort()[-10:][::-1]
recommended_movie_ids = [
    movie_encoded_to_movie.get(movie_not_watched[x][0]) for x in top_ratings_indices
]

print('Showing recommendations for users: {}'.format(user_id))
print('===' * 9)
print('Movies with high ratings from user')
print('----' * 8)

top_movie_user = (
    movie_watched_by_user.sort_values(
        by = 'rating',
        ascending=False
    )
    .head(5)
    .movieId.values
)

movie_df_rows = movie_df[movie_df['id'].isin(top_movie_user)]
for row in movie_df_rows.itertuples():
    print(row.movie_title, ':', row.movie_genres)

print('----' * 8)
print('Top 10 Movies Recommendation')
print('----' * 8)

recommended_movies = movie_df[movie_df['id'].isin(recommended_movie_ids)]
for row in recommended_movies.itertuples():
    print(row.movie_title, ':', row.movie_genres)

"""Berikut kesimpulan akhir berdasarkan output rekomendasi untuk user dengan userId 376:

Dari hasil implementasi sistem rekomendasi menggunakan pendekatan **Collaborative Filtering**, kita berhasil memberikan rekomendasi yang relevan dan sesuai dengan preferensi pengguna. Dalam contoh ini, sistem menghasilkan rekomendasi untuk pengguna dengan userId 376, yang sebelumnya memberikan rating tinggi pada film bergenre *Sci-Fi*, *Drama*, *Thriller*, dan *War*, seperti **Twelve Monkeys**, **Apollo 13**, dan **Terminator 2**.

Rekomendasi yang diberikan pun menunjukkan konsistensi dengan pola preferensi pengguna. Film seperti **Band of Brothers**, **Paths of Glory**, dan **The Stunt Man** memiliki elemen genre yang selaras, terutama *Drama*, *War*, dan *Thriller*. Selain itu, sistem juga menyarankan beberapa film dari genre lain seperti *Comedy* dan *Romance*, menunjukkan bahwa model mampu mengenali kemungkinan preferensi tambahan berdasarkan kemiripan perilaku pengguna lain yang serupa.

Secara keseluruhan, hasil ini menunjukkan bahwa sistem **Collaborative Filtering** telah mampu mengidentifikasi pola dan memberikan rekomendasi film yang dipersonalisasi dengan baik, tanpa memerlukan data konten dari masing-masing film secara langsung. Keunggulan pendekatan ini terletak pada kemampuannya untuk menemukan kesamaan antar pengguna dan menggunakannya sebagai dasar rekomendasi, menjadikannya solusi yang efektif untuk sistem dengan interaksi pengguna yang cukup besar.

"""